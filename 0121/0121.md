# 0121

# view.transform
* 用来描述view的形变属性
```objectivec
        //使用Make,它是相对于最原始的位置做的形变.
        //self.imageV.transform = CGAffineTransformMakeTranslation(0, -100);
        //相对于上一次做形变.
        self.imageV.transform = CGAffineTransformTranslate(self.imageV.transform, 0, -100);
        
        //旋转(旋转的度数, 是一个弧度)
        //self.imageV.transform = CGAffineTransformMakeRotation(M_PI_4);
        self.imageV.transform = CGAffineTransformRotate(self.imageV.transform, M_PI_4);
        
        //缩放(相对于1)
        //self.imageV.transform = CGAffineTransformMakeScale(0.5, 0.5);
        self.imageV.transform = CGAffineTransformScale(self.imageV.transform, 0.8, 0.8);
```

# UIResponder响应者对象
* 在iOS中不是所有对象都能处理事件,只有继承自UIResponder的对象才能接受并处理事件
![](/grammar/images/20140320225429296.png)

* iOS中共有三大类事件 : 触摸事件,加速计事件,远程控制事件

![](/0121/images/WX20170808-192801.png)
> NSSet集合是无序的,NSArray是有序的

# iOS中的触摸事件
* UIView的触摸事件
![](/0121/images/WX20170808-193110.png)

## UITouch

* 当用户用一根手指触摸屏幕时,会创建一个与手指相关联的UITouch对象
* 一根手指对应一个UITouch对象
* UITouch的作用是保存着跟手指相关的信息，比如触摸的位置、时间、阶段
* 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存
该手指在的触摸位置
* 当手指离开屏幕时，系统会销毁相应的UITouch对象

### UITouch属性

触摸产生时所处的窗口
@property(nonatomic,readonly,retain) UIWindow    *window;

触摸产生时所处的视图@property(nonatomic,readonly,retain) UIView      *view;

短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击@property(nonatomic,readonly) NSUInteger          tapCount;

记录了触摸事件产生或变化时的时间，单位是秒@property(nonatomic,readonly) NSTimeInterval      timestamp;

当前触摸事件所处的状态@property(nonatomic,readonly) UITouchPhase        phase;

### UITouch方法
\- (CGPoint)locationInView:(UIView *)view;
返回值表示触摸在view上的位置,这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置

\- (CGPoint)previousLocationInView:(UIView *)view;该方法记录了前一个触摸点的位置

#### view跟随手指移动

```objectivec
- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    UITouch *touch = [touches anyObject];
    CGPoint curP = [touch locationInView:self];
    CGPoint preP = [touch previousLocationInView:self];
    CGFloat offsetX = curP.x -preP.x;
    CGFloat offsetY = curP.y -preP.y;
    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);
    self.transform = CGAffineTransformRotate(self.transform, M_PI_4);
}
```





